<html>
	<head>
		https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js
		<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro&display=swap" rel="stylesheet">
		<script src='https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js'></script>
		<link rel="stylesheet" type="text/css" href="style.css">
		<title>Рекурсивные функции</title>
	</head>
	<body>
		<div id="main-doc">
			<div id='navbar'>
			<nav><a href="#recurive_functions">Рекурсивные функции</a> | 
				 <a href="#anatomy_of_recursive_functions">Анатомия рекурсивных функций</a> | 
				 <a href="#mutual_recursion">Взаимная рекурсия</a> | 
				 <a href="#tree_recursion">Древовидная рекурсия</a></nav>
			</div>
			<section id="recurive_functions" class="main-section">
				<hr>
				<header>Рекурсивные функции</header>
				<hr>
				<p>
					Функция называется рекурсивной, если она вызывает сама
					себя. Процесс выполнения тела рекурсивной функции может
					требовать повторного вызова данной функции.
				</p>
				<p>
					Пример: напишем функцию, которая складывает цифры в 
					натуральном числе. В процессе создания рекурсивных 
					функций, необходимо рассматривать пути разбиения сложной
					задачи на несколько простых. Например, используя операторы
					целочисленного деления <b>//</b> и остатка от деления <b>%</b> можно 
					разбить число на две части: последняя цифра и всё остальное,
					кроме последней цифры.
				</p>
				<div class="code-block">
				<code>
<span class="invitation">>>></span> 18117 % 10
7
<span class="invitation">>>></span> 18117 // 10
1811</code>
				</div>
				<p>
					Сумма цифр числа <b>18117</b> равна <b>1+8+1+1+7 = 18</b>. Мы можем разбить 
					эту сумму, также как мы разбили исходное число на цифру <b>7</b> и 
					сумму всего остального, кроме последней цифры, <b>1+8+1+1 = 11</b>. 
					Данные разбиения дают нам алгоритм: чтобы сложить цифры натурального
					числа <b>n</b>, необходимо прибавить его последнюю цифру <b>n % 10</b> 
					к сумме всех цифр, кроме последней <b>n // 10</b>. Есть один особенный 
					случай: если число содержит только одну цифру, тогда сумма цифр этого числа 
					- это само число. Данный алгоритм может быть реализован как рекурсивная 
					функция.
				</p>
				<div class="code-block">
				<code>
<span class="invitation">>>></span> <span class="keyword">def</span> sum_digits(n):
	<span class="invitation">"""Возвращает сумму цифр в положительном числе n."""</span>
	<span class="keyword">if</span> n < 10:
		<span class="keyword">return</span> n
	<span class="keyword">else</span>:
		all_but_last, last = n // 10, n % 10
		<span class="keyword">return</span> sum_digits(all_but_last) + last</code>
				</div>
				<p>
					Определение функции <b>sum_digits</b> является верным, несмотря на то, что внутри 
					тела функции происходит вызов самой себя. Задача сложения цифр натурального числа
					состоит из двух этапов: сложить всё, кроме последней цифры, после чего прибавить 
					последнюю цифру. Оба этих этапа проще, чем изначальная задача. Функция является 
					рекурсивной потому что её первый этап - это та же задача, что и исходная. Проверим 
					результат выполнения функции.
				</p>
				<div class="code-block">
				<code>
<span class="invitation">>>></span> sum_digits(9)
9
<span class="invitation">>>></span> sum_digits(18117)
18
<span class="invitation">>>></span> sum_digits(9437184)
36</code>
				</div>
				<p>
					Этот пример также иллюстрирует, как простые функции могут развивать сложные вычислительные процессы 
					с помощью рекурсии.
				</p>
			</section>
			<section id="anatomy_of_recursive_functions" 
				class="main-section">
				<hr>
				<header>Анатомия рекурсивных функций</header>
				<hr>
				<p>
					Общий паттерн можно найти в теле многих рекурсивных функций. Тело начинается с базового 
					случая, условного оператора, который определяет поведение функции для входных данных, 
					которые проще всего обрабатывать. В случае <b>sum_digits</b>, базовый случай - это одна любая 
					цифра, тогда мы просто возвращаем её. Некоторые рекурсивные функции имеют несколько базовых
					случаев.
				</p>
				<p>
					После базового случая следуют один или несколько рекурсивных вызовов. Рекурсивные вызовы всегда
					делают одно и то же: они упрощают исходную задачу. Рекурсивные функции выражают вычисления путем 
					постепенного упрощения задач. Например, суммирование цифры 7 проще, чем суммирование цифр 73, что, 
					в свою очередь, проще, чем суммирование цифр 738. Для каждого последующего вызова остается меньше работы.
				</p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
			</section>
			<section id="mutual_recursion" class="main-section">
				<hr>
				<header>Взаимная рекурсия</header>
				<hr>
				<p>
					Когда рекурсивная процедура разделена между двумя функциями, которые вызывают друг друга, функции называются взаимно
					рекурсивными. В качестве примера рассмотрим следующее определение четного и нечетного для неотрицательных целых чисел:
				</p>
				<ul>
					<li>число является четным, если оно на единицу больше нечетного числа</li>
					<li>число является нечетным, если оно на единицу больше четного числа</li>
					<li>0 является четным</li>
				</ul>
				<p>
					Используя это определение, мы можем реализовать взаимно рекурсивные функции, чтобы определить, является ли число четным
					или нечетным:
				</p>
				<div class="code-block">
				<code>
<span class="invitation">>>></span> <span class="keyword">def</span> is_even(n):
	<span class="keyword">if</span> n == 0:
		<span class="keyword">return True</span>
	<span class="keyword">else</span>:
		<span class="keyword">return</span> is_odd(n-1)

<span class="invitation">>>></span> <span class="keyword">def</span> is_odd(n):
	<span class="keyword">if</span> n == 0:
		<span class="keyword">return False</span>
	<span class="keyword">else</span>:
		<span class="keyword">return</span> is_even(n-1)

<span class="invitation">>>></span> result = is_even(4)</code>
				</div>
				<p>
					Взаимно рекурсивные функции можно превратить в единую рекурсивную функцию, нарушив границу 
					абстракции между этими двумя функциями. В этом примере тело <b>is_odd</b> может быть включено в 
					тело <b>is_even</b>, обязательно заменяя <b>n</b> на <b>n-1</b> в теле <b>is_odd</b>, чтобы отразить аргумент, переданный 
					в него:
				</p>
				<div class="code-block">
				<code>
<span class="invitation">>>></span> <span class="keyword">def</span> is_even(n):
	<span class="keyword">if</span> n == 0:
		<span class="keyword">return True</span>
	<span class="keyword">else</span>:
		<span class="keyword">if</span> (n-1) == 0:
			<span class="keyword">return False</span>
		<span class="keyword">else</span>:
			<span class="keyword">return</span> is_even((n-1)-1)</code>
				</div>
				<p>
					Как таковая, взаимная рекурсия не более таинственна или могущественна, чем простая рекурсия, и она обеспечивает механизм
					для поддержания абстракции в рамках сложной рекурсивной программы.
				</p>
			</section>
			<section id="tree_recursion" class="main-section">
				<hr>
				<header>Древовидная рекурсия</header>
				<hr>
				<p>
					Ещё один паттерн вычислений называется древовидная рекурсия, суть которого в том, что функция 
					вызывает себя больше одного раза. В качестве примера рассмотрим вычисление последовательности 
					чисел Фибоначчи, в которой каждое число является суммой двух предыдущих.
				</p>
				<div class="code-block">
				<code>
<span class="invitation">>>></span> <span class="keyword">def</span> fib(n):
	<span class="keyword">if</span> n == 1:
		<span class="keyword">return</span> 0
	<span class="keyword">if</span> n == 2:
		<span class="keyword">return</span> 1	
	<span class="keyword">else</span>:
		<span class="keyword">return</span> fib(n-2) + fib(n-1)</code>
				</div>
				<p>
					Это рекурсивное определение чрезвычайно привлекательно по сравнению с нашими предыдущими попытками: 
					оно точно отражает знакомое определение чисел Фибоначчи. Функция с несколькими рекурсивными вызовами 
					называется функцией с древовидной рекурсией, потому что каждый вызов разветвляется на несколько меньших вызовов, 
					каждый из которых разветвляется на еще меньшие вызовы, точно так же, как ветви дерева становятся меньше, 
					но более многочисленными, когда они расширяются от ствола.
				</p>
			</section>
			<footer>
				<div>
				Original: <a href="https://composingprograms.com/pages/17-recursive-functions.html">composing programs</a>
				</div>
				<div class="github">Made by <a href="https://github.com/renmans"><span class="keyword">@renmans</span></a></div>
			</footer>
		</div>
	</body>
</html>
